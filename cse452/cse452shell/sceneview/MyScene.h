#ifndef _MY_SCENE_H_
#define _MY_SCENE_H_

#include "cse452.h"
#include "Color.h"
#include "camera/Camera.h"
#include "parser.h"
#include "Light.h"
#include "Shape.h"
#include "Cone.h"
#include "Sphere.h"
#include "Cylinder.h"
#include "Cube.h"
#include <FL/Fl_Image.H>
#include <string>
#include <vector>
#include <unordered_map>
#include <string>
#include <memory>
using namespace std;

/*
 * This class holds all of the data in the scene file.
 *  Camera
 *  Lights
 *  Subgraphs
 *  Root subgraph
 */

// ToDo: Define these
class Object{
public:
	int shape; // 0 for Cube, 1 for Cylinder, 2 for Cone, 3 for Sphere, 4 for Ellipsoid
	shared_ptr <Shape> shapeptr;
	Color diffuse, specular, ambient, reflect, transparent, emit;
	double textureU, textureV, ior, shine;
	Matrix4 trans, trans_inv;
	string texture;
	void flatten(vector<Object>*, Matrix4);
};

class Node{
public:
	Object* obj;
	vector<Node*> children;
	Matrix4 transform;
	bool hasObj;
	void flatten(vector<Object>*, Matrix4);
};

class Tree{};

class MyScene {
public:
    MyScene();
    ~MyScene();

    // The start of the parsing routine
    // Called once when a new scene file is opened
    bool loadSceneFile(std::string filename);

    // Return the current error mesage (if any) generated by parsing
    string getErrorMessage() const;

    // Return the parsed camera
    Camera &changeCamera();

    // Return the parsed camera
    const Camera &getCamera() const;

    // Return the parsed camera
    const Color &getBackground() const;

    // Called when the window is re-sized
    void resize(int w, int h);
    // Called when the window needs to be re-drawn
    // Stub can be found in sceneview/MyScene_draw.cpp
    void draw();
    
    /* 
     * The following are for the user interaction assignment 
     * Stubs for them can be found in Interactive/MySceneSelect.cpp
     */
    // User clicked on the screen; find the corresponding shape
    bool selectNode(int x, int y);
    //
    void moveSelectedNode( const Matrix4 &matChange );
    
    /*
     * The following are for the ray tracing assignment
     * Stubs for them can be found in rendering/MyScene_render.cpp
     */
    // 
    void render(int type, int width, int height, unsigned char* pixels);
    void stopRender();
    double getRenderProgress();

    /*
     * The following are for the sceneview assignment
     * They can be found in sceneview/MyScene.cpp
     */
    // Clear out any existing data
    void resetScene();

    // Gets the background color from the scenefile
    bool parseBackground(Parser& p);

    // Gets the camera info (if any) from the scene file
    bool parseCamera(Parser& p);

    // Gets the light info (if any) from the scene file
    bool parseLight(Parser& p);

    /*
     * The following are the parsing routines you need to finish filling in.
     * Feel free to change the return type or pass in additional parameters.
     */
    // Called when subgraph _name_ [ is encountered in the scene file
    // Should return true when root subgraph encountered
    Node* parseMasterSubgraph(Parser& p);

    // Called when trans [ is encountered
    Node* parseTrans(Parser& p);

    // Called when Object _name_ [ is encountered
    Object* parseObject(Parser& p);
  
private:
    // Has loadSceneFile been called yet?
    bool isLoaded;
    // Keep track of the current error message
    std::string errorMessage;
    
    // Store camera info; remember that your default camera should be
    // set to reasonable values in case there is no camera information
    // in the scene file
    Camera camera;

    // Stores the background color found in the scenefile (if any).
    // Defaults to black
    Color background;

    // The stored lights
    Color ambientLight;
    std::vector<Light> lights;

    // your functions/variables go here
	std::unordered_map<std::string, Node*> map;
	vector<Object> objList;
	vector<Node*> nodes;
	vector<Object*> objs;
	const int RECURSIVE_LIMIT = 5;
	double progress, w, h, SHIFT = 0.001;
	Point3 eye;
	bool stop;

	void traceRay(double&, double&, double&, double&, double&);
	void lightToScene(const Vector3&, const Point3&, double&, double&, double&, int levels);
	void findIntersect(const Vector3, const Point3, Object *&, Vector3 &, Point3 &);
	void normalizeColor(double&, double&, double&);
};

#endif /* _MY_SCENE_H_ */
